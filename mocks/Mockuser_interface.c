/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockuser_interface.h"

static const char* CMockString_account = "account";
static const char* CMockString_buffer = "buffer";
static const char* CMockString_error_msg = "error_msg";
static const char* CMockString_get_nonempty_input = "get_nonempty_input";
static const char* CMockString_get_valid_balance = "get_valid_balance";
static const char* CMockString_get_validated_input = "get_validated_input";
static const char* CMockString_msg = "msg";
static const char* CMockString_open_file_error = "open_file_error";
static const char* CMockString_print_account_confirmation = "print_account_confirmation";
static const char* CMockString_print_message = "print_message";
static const char* CMockString_prompt = "prompt";
static const char* CMockString_size = "size";
static const char* CMockString_validate = "validate";
static const char* CMockString_value = "value";

typedef struct _CMOCK_open_file_error_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_open_file_error_CALL_INSTANCE;

typedef struct _CMOCK_print_account_confirmation_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const BankAccount* Expected_account;

} CMOCK_print_account_confirmation_CALL_INSTANCE;

typedef struct _CMOCK_get_nonempty_input_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* Expected_prompt;
  char* Expected_buffer;
  int Expected_size;

} CMOCK_get_nonempty_input_CALL_INSTANCE;

typedef struct _CMOCK_get_validated_input_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* Expected_prompt;
  char* Expected_buffer;
  int Expected_size;
  cmock_user_interface_func_ptr1 Expected_validate;
  const char* Expected_error_msg;

} CMOCK_get_validated_input_CALL_INSTANCE;

typedef struct _CMOCK_get_valid_balance_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* Expected_prompt;
  double* Expected_value;

} CMOCK_get_valid_balance_CALL_INSTANCE;

typedef struct _CMOCK_print_message_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  const char* Expected_msg;

} CMOCK_print_message_CALL_INSTANCE;

static struct Mockuser_interfaceInstance
{
  CMOCK_MEM_INDEX_TYPE open_file_error_CallInstance;
  CMOCK_MEM_INDEX_TYPE print_account_confirmation_CallInstance;
  CMOCK_MEM_INDEX_TYPE get_nonempty_input_CallInstance;
  CMOCK_MEM_INDEX_TYPE get_validated_input_CallInstance;
  CMOCK_MEM_INDEX_TYPE get_valid_balance_CallInstance;
  CMOCK_MEM_INDEX_TYPE print_message_CallInstance;
} Mock;


void Mockuser_interface_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.open_file_error_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_open_file_error);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.print_account_confirmation_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_print_account_confirmation);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.get_nonempty_input_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_get_nonempty_input);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.get_validated_input_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_get_validated_input);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.get_valid_balance_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_get_valid_balance);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.print_message_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_print_message);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockuser_interface_Init(void)
{
  Mockuser_interface_Destroy();
}

void Mockuser_interface_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void open_file_error(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_open_file_error_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_open_file_error);
  cmock_call_instance = (CMOCK_open_file_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.open_file_error_CallInstance);
  Mock.open_file_error_CallInstance = CMock_Guts_MemNext(Mock.open_file_error_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void open_file_error_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_open_file_error_CALL_INSTANCE));
  CMOCK_open_file_error_CALL_INSTANCE* cmock_call_instance = (CMOCK_open_file_error_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.open_file_error_CallInstance = CMock_Guts_MemChain(Mock.open_file_error_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void print_account_confirmation(const BankAccount* account)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_print_account_confirmation_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_print_account_confirmation);
  cmock_call_instance = (CMOCK_print_account_confirmation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.print_account_confirmation_CallInstance);
  Mock.print_account_confirmation_CallInstance = CMock_Guts_MemNext(Mock.print_account_confirmation_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_print_account_confirmation,CMockString_account);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_account), (void*)(account), sizeof(const BankAccount), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_print_account_confirmation(CMOCK_print_account_confirmation_CALL_INSTANCE* cmock_call_instance, const BankAccount* account);
void CMockExpectParameters_print_account_confirmation(CMOCK_print_account_confirmation_CALL_INSTANCE* cmock_call_instance, const BankAccount* account)
{
  cmock_call_instance->Expected_account = account;
}

void print_account_confirmation_CMockExpect(UNITY_LINE_TYPE cmock_line, const BankAccount* account)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_print_account_confirmation_CALL_INSTANCE));
  CMOCK_print_account_confirmation_CALL_INSTANCE* cmock_call_instance = (CMOCK_print_account_confirmation_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.print_account_confirmation_CallInstance = CMock_Guts_MemChain(Mock.print_account_confirmation_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_print_account_confirmation(cmock_call_instance, account);
}

void get_nonempty_input(const char* prompt, char* buffer, int size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_get_nonempty_input_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_get_nonempty_input);
  cmock_call_instance = (CMOCK_get_nonempty_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.get_nonempty_input_CallInstance);
  Mock.get_nonempty_input_CallInstance = CMock_Guts_MemNext(Mock.get_nonempty_input_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_get_nonempty_input,CMockString_prompt);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_prompt, prompt, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_nonempty_input,CMockString_buffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_buffer, buffer, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_nonempty_input,CMockString_size);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_size, size, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_get_nonempty_input(CMOCK_get_nonempty_input_CALL_INSTANCE* cmock_call_instance, const char* prompt, char* buffer, int size);
void CMockExpectParameters_get_nonempty_input(CMOCK_get_nonempty_input_CALL_INSTANCE* cmock_call_instance, const char* prompt, char* buffer, int size)
{
  cmock_call_instance->Expected_prompt = prompt;
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_size = size;
}

void get_nonempty_input_CMockExpect(UNITY_LINE_TYPE cmock_line, const char* prompt, char* buffer, int size)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_get_nonempty_input_CALL_INSTANCE));
  CMOCK_get_nonempty_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_get_nonempty_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.get_nonempty_input_CallInstance = CMock_Guts_MemChain(Mock.get_nonempty_input_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_get_nonempty_input(cmock_call_instance, prompt, buffer, size);
}

void get_validated_input(const char* prompt, char* buffer, int size, cmock_user_interface_func_ptr1 validate, const char* error_msg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_get_validated_input_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_get_validated_input);
  cmock_call_instance = (CMOCK_get_validated_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.get_validated_input_CallInstance);
  Mock.get_validated_input_CallInstance = CMock_Guts_MemNext(Mock.get_validated_input_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_get_validated_input,CMockString_prompt);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_prompt, prompt, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_validated_input,CMockString_buffer);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_buffer, buffer, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_validated_input,CMockString_size);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_size, size, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_validated_input,CMockString_validate);
    UNITY_TEST_ASSERT_EQUAL_PTR(cmock_call_instance->Expected_validate, validate, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_validated_input,CMockString_error_msg);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_error_msg, error_msg, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_get_validated_input(CMOCK_get_validated_input_CALL_INSTANCE* cmock_call_instance, const char* prompt, char* buffer, int size, cmock_user_interface_func_ptr1 validate, const char* error_msg);
void CMockExpectParameters_get_validated_input(CMOCK_get_validated_input_CALL_INSTANCE* cmock_call_instance, const char* prompt, char* buffer, int size, cmock_user_interface_func_ptr1 validate, const char* error_msg)
{
  cmock_call_instance->Expected_prompt = prompt;
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_size = size;
  memcpy((void*)(&cmock_call_instance->Expected_validate), (const void*)(&validate),
         sizeof(cmock_user_interface_func_ptr1[sizeof(validate) == sizeof(cmock_user_interface_func_ptr1) ? 1 : -1])); /* add cmock_user_interface_func_ptr1 to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_error_msg = error_msg;
}

void get_validated_input_CMockExpect(UNITY_LINE_TYPE cmock_line, const char* prompt, char* buffer, int size, cmock_user_interface_func_ptr1 validate, const char* error_msg)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_get_validated_input_CALL_INSTANCE));
  CMOCK_get_validated_input_CALL_INSTANCE* cmock_call_instance = (CMOCK_get_validated_input_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.get_validated_input_CallInstance = CMock_Guts_MemChain(Mock.get_validated_input_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_get_validated_input(cmock_call_instance, prompt, buffer, size, validate, error_msg);
}

void get_valid_balance(const char* prompt, double* value)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_get_valid_balance_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_get_valid_balance);
  cmock_call_instance = (CMOCK_get_valid_balance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.get_valid_balance_CallInstance);
  Mock.get_valid_balance_CallInstance = CMock_Guts_MemNext(Mock.get_valid_balance_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_get_valid_balance,CMockString_prompt);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_prompt, prompt, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_get_valid_balance,CMockString_value);
    if (cmock_call_instance->Expected_value == NULL)
      { UNITY_TEST_ASSERT_NULL(value, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_FLOAT_ARRAY(cmock_call_instance->Expected_value, value, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_get_valid_balance(CMOCK_get_valid_balance_CALL_INSTANCE* cmock_call_instance, const char* prompt, double* value);
void CMockExpectParameters_get_valid_balance(CMOCK_get_valid_balance_CALL_INSTANCE* cmock_call_instance, const char* prompt, double* value)
{
  cmock_call_instance->Expected_prompt = prompt;
  cmock_call_instance->Expected_value = value;
}

void get_valid_balance_CMockExpect(UNITY_LINE_TYPE cmock_line, const char* prompt, double* value)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_get_valid_balance_CALL_INSTANCE));
  CMOCK_get_valid_balance_CALL_INSTANCE* cmock_call_instance = (CMOCK_get_valid_balance_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.get_valid_balance_CallInstance = CMock_Guts_MemChain(Mock.get_valid_balance_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_get_valid_balance(cmock_call_instance, prompt, value);
}

void print_message(const char* msg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_print_message_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_print_message);
  cmock_call_instance = (CMOCK_print_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.print_message_CallInstance);
  Mock.print_message_CallInstance = CMock_Guts_MemNext(Mock.print_message_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_print_message,CMockString_msg);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_msg, msg, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_print_message(CMOCK_print_message_CALL_INSTANCE* cmock_call_instance, const char* msg);
void CMockExpectParameters_print_message(CMOCK_print_message_CALL_INSTANCE* cmock_call_instance, const char* msg)
{
  cmock_call_instance->Expected_msg = msg;
}

void print_message_CMockExpect(UNITY_LINE_TYPE cmock_line, const char* msg)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_print_message_CALL_INSTANCE));
  CMOCK_print_message_CALL_INSTANCE* cmock_call_instance = (CMOCK_print_message_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.print_message_CallInstance = CMock_Guts_MemChain(Mock.print_message_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_print_message(cmock_call_instance, msg);
}

